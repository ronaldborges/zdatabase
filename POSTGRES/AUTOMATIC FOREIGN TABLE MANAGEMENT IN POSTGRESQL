++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+   AUTOMATIC FOREIGN TABLE MANAGEMENT IN POSTGRESQL   +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#NOTE
Foreign tables are external tables that usually have orgies in other instances of databases, 
that have a different maintenance team and that often do not establish direct communication. 
When the original table is modified, the foreign table may become unusable. 
Needing to be recreated or modified to correct its characteristics. 
The idea of the solution is to automate the process of updating foreign tables in postgres.


#CREATE TABLE REGISTER FOREING TABLES

create table fdw_tables_list
(schema_name character varying not NULL,
table_name character varying not NULL,
foreign_server_name character varying not null,
usename character varying not null,
CONSTRAINT fdw_tables_list_pku UNIQUE (schema_name, table_name, foreign_server_name));

#INSERT EXISTENT FOREIGN TABLES

INSERT INTO public.fdw_tables_list(schema_name, table_name, foreign_server_name, usename)
SELECT foreign_table_schema, t.foreign_table_name, s.foreign_server_name, u.usename
FROM information_schema.foreign_tables t join information_schema.foreign_servers s on t.foreign_server_catalog = s.foreign_server_catalog
join pg_class c on t.foreign_table_name = c.relname
join pg_user u on c.relowner = u.usesysid;

#GENERATE FOREIGN TABLE METADATA POSTGRES

SELECT                                          
  'CREATE FOREIGN TABLE ' || table_schema || '.' || relname || E'\n(\n' ||
  array_to_string(
    array_agg(
      '    ' || column_name || ' ' ||  type || ' '|| not_null
    )
    , E',\n'
  ) || E'\n)\n SERVER ' || foreign_server_name  || E'\n OPTIONS (schema_name ''' || table_schema || ''', table_name ''' || relname || ''');' || E'\n ALTER TABLE ' || table_schema || '.' || relname || ' OWNER TO ' || usename || ';' || E'\n GRANT SELECT ON TABLE ' || table_schema || '.' || relname || ' TO ' || usename || ';'
from
(
  SELECT 
    c.relname, a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as type,
    case 
      when a.attnotnull
    then 'NOT NULL' 
    else 'NULL' 
    END as not_null, s.foreign_server_name, ts.table_schema, u.usename 
  FROM pg_attribute a,
   pg_type t,
   information_schema.tables ts
   join information_schema.foreign_servers s on ts.table_catalog = s.foreign_server_catalog
   join pg_class c on ts.table_name = c.relname
   join pg_user u on c.relowner = u.usesysid
   where ts.table_schema not in ('information_schema', 'pg_catalog') and ts.table_type = 'FOREIGN'
   AND a.attnum > 0
   AND a.attrelid = c.oid
   AND a.atttypid = t.oid
 ORDER BY a.attnum
) as tabledefinition
group by relname, foreign_server_name, table_schema, usename;

#CREATE FOREIGN TABLES FOR MANAGE METADATA
CREATE FOREIGN TABLE public.pg_attribute_f (
 attrelid oid not null, 
 attname name not null, 
 atttypid oid not null,
 attstattarget integer not null,
 attlen smallint not null,
 attnum smallint not null,
 attndims integer not null,
 attcacheoff integer not null,
 atttypmod integer not null,
 attbyval boolean not null,
 attstorage char not null,
 attalign char not null,
 attnotnull boolean not null,
 atthasdef boolean not null,
 atthasmissing boolean not null,
 attidentity char not null,
 attisdropped boolean not null,
 attislocal boolean not null,
 attinhcount integer not null,
 attcollation oid not null,
 attacl aclitem[],
 attoptions text[],
 attfdwoptions text[],
 attmissingval anyarray)
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_attribute');

ALTER TABLE public.pg_attribute_f OWNER TO postgres;
GRANT SELECT ON TABLE public.pg_attribute_f TO postgres;

CREATE FOREIGN TABLE public.pg_type_f (
 typname name not null,
 typnamespace oid not null,
 typowner oid not null,
 typlen smallint not null,
 typbyval boolean not null,
 typtype "char" not null,
 typcategory "char" not null, 
 typispreferred boolean not null,
 typisdefined boolean not null,
 typdelim "char" not null,
 typrelid oid not null,
 typelem oid not null,
 typarray oid not null,
 typinput regproc not null,
 typoutput regproc not null,
 typreceive regproc not null,
 typsend regproc not null,
 typmodin regproc not null,
 typmodout regproc not null,
 typanalyze regproc not null,
 typalign "char" not null,
 typstorage "char" not null,
 typnotnull boolean not null,
 typbasetype oid not null,
 typtypmod integer not null,
 typndims integer not null,
 typcollation oid not null,
 typdefaultbin pg_node_tree,
 typdefault text, 
 typacl aclitem[])
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_type');

ALTER TABLE public.pg_type_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_type_f TO postgres;

CREATE FOREIGN TABLE public.information_schema_tables_f (
 table_catalog information_schema.sql_identifier,
 table_schema information_schema.sql_identifier,
 table_name information_schema.sql_identifier,
 table_type information_schema.character_data,
 self_referencing_column_name information_schema.sql_identifier,
 reference_generation information_schema.character_data,
 user_defined_type_catalog information_schema.sql_identifier,
 user_defined_type_schema information_schema.sql_identifier,
 user_defined_type_name information_schema.sql_identifier,
 is_insertable_into information_schema.yes_or_no,
 is_typed information_schema.yes_or_no,
 commit_action information_schema.character_data)
SERVER fdw_pg11
OPTIONS (schema_name 'information_schema', table_name 'tables');

ALTER TABLE public.information_schema_tables_f OWNER TO postgres;
GRANT ALL ON TABLE public.information_schema_tables_f TO postgres;

CREATE FOREIGN TABLE public.information_schema_foreign_servers_f (
 foreign_server_catalog information_schema.sql_identifier, 
 foreign_server_name information_schema.sql_identifier, 
 foreign_data_wrapper_catalog information_schema.sql_identifier, 
 foreign_data_wrapper_name information_schema.sql_identifier, 
 foreign_server_type information_schema.character_data, 
 foreign_server_version information_schema.character_data, 
 authorization_identifier information_schema.sql_identifier)
SERVER fdw_pg11
OPTIONS (schema_name 'information_schema', table_name 'tables');

ALTER TABLE public.information_schema_foreign_servers_f OWNER TO postgres;
GRANT ALL ON TABLE public.information_schema_foreign_servers_f TO postgres;

CREATE FOREIGN TABLE public.pg_class_f (
	oid oid not null,
	relname char[] NOT NULL,
	relnamespace oid NOT NULL,
	reltype oid NOT NULL,
	reloftype oid NOT NULL,
	relowner oid NOT NULL,
	relam oid NOT NULL,
	relfilenode oid NOT NULL,
	reltablespace oid NOT NULL,
	relpages int4 NOT NULL,
	reltuples float4 NOT NULL,
	relallvisible int4 NOT NULL,
	reltoastrelid oid NOT NULL,
	relhasindex bool NOT NULL,
	relisshared bool NOT NULL,
	relpersistence char(1) NOT NULL,
	relkind char(1) NOT NULL,
	relnatts int2 NOT NULL,
	relchecks int2 NOT NULL,
	relhasoids bool NOT NULL,
	relhasrules bool NOT NULL,
	relhastriggers bool NOT NULL,
	relhassubclass bool NOT NULL,
	relrowsecurity bool NOT NULL,
	relforcerowsecurity bool NOT NULL,
	relispopulated bool NOT NULL,
	relreplident char(1) NOT NULL,
	relispartition bool NOT NULL,
	relrewrite oid NOT NULL,
	relfrozenxid xid NOT NULL,
	relminmxid xid NOT NULL,
	relacl aclitem[] NULL,
	reloptions text[] NULL,
	relpartbound pg_node_tree NULL
)
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_class');

ALTER TABLE public.pg_class_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_class_f TO postgres;

CREATE FOREIGN TABLE public.pg_user_f (
usename name, 
usesysid oid,  
usecreatedb boolean, 
usesuper boolean, 
userepl boolean, 
usebypassrls boolean, 
passwd text, 
valuntil abstime, 
useconfig text[]) 
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_user');

ALTER TABLE public.pg_user_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_user_f TO postgres;




